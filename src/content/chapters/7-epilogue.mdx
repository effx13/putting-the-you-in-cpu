---
chapter: 7
title: 에필로그
shortname: Epilogue
slug: epilogue
updatedAt: 2023-07-18T18:59:25.355Z
---

축하합니다! 우리는 이제 CPU에 "당신(you)"을 확실히 넣었습니다. 즐거웠기를 바랍니다.

방금 얻은 모든 지식이 실제적이고 활동적이라는 것을 한 번 더 강조하며 보내드립니다. 다음에 컴퓨터가 여러 앱을 실행하는 것에 대해 생각할 때, 타이머 칩과 하드웨어 인터럽트를 상상하기를 바랍니다. 멋진 프로그래밍 언어로 프로그램을 작성하고 링커 오류가 발생하면, 그 링커가 무엇을 하려고 하는지 생각하기를 바랍니다.

이 글에 포함된 내용에 대해 질문이 있거나 (또는 수정 사항이 있다면) [lexi@hackclub.com](mailto:lexi@hackclub.com)으로 이메일을 보내거나 [GitHub](https://github.com/hackclub/putting-the-you-in-cpu/)에 이슈나 PR을 제출해야 합니다.

<img src='/images/the-end.png' loading='eager' alt='끝.' width='1367' height='331' style='max-width: 600px; margin: 30px auto; margin-bottom: 150px;' />

... 하지만 잠깐, 더 있습니다!

## 보너스: C 개념 번역하기

저수준 프로그래밍을 직접 해본 적이 있다면, 스택과 힙이 무엇인지 알고 있을 것이고 `malloc`을 사용해봤을 것입니다. 그것들이 어떻게 구현되는지에 대해 많이 생각하지 않았을 수도 있습니다!

우선, 스레드의 스택은 가상 메모리의 높은 곳에 매핑된 고정된 양의 메모리입니다. 대부분의 (비록 [모든](https://stackoverflow.com/a/664779) 것은 아니지만) 아키텍처에서, 스택 포인터는 스택 메모리의 맨 위에서 시작하여 증가할 때 아래로 이동합니다. 물리 메모리는 전체 매핑된 스택 공간에 대해 미리 할당되지 않습니다; 대신, 요구 페이징이 스택의 프레임에 도달할 때 느리게 메모리를 할당하는 데 사용됩니다.

`malloc`과 같은 힙 할당 함수가 시스템 콜이 아니라는 것을 듣는 것은 놀라울 수 있습니다. 대신, 힙 메모리 관리는 libc 구현에 의해 제공됩니다! `malloc`, `free` 등은 복잡한 절차이며, libc는 메모리 매핑 세부 사항을 스스로 추적합니다. 내부적으로, 사용자 공간 힙 할당자는 `mmap` (파일 이상을 매핑할 수 있음)과 `sbrk`를 포함한 시스템 콜을 사용합니다.

## 보너스: 잡학

이것들을 일관성 있게 넣을 곳을 찾지 못했지만, 재미있다고 생각했으므로, 여기 있습니다.

> *대부분의 Linux 사용자는 아마도 커널에서 페이지 테이블이 어떻게 표현되는지 상상하는 데 시간을 거의 소비하지 않을 만큼 충분히 흥미로운 삶을 가지고 있을 것입니다.*
>
> *<cite>[Jonathan Corbet, LWN](https://lwn.net/Articles/106177/)</cite>*

하드웨어 인터럽트의 대체 시각화:

<img src='/images/hardware-interrupt-meme.png' loading='lazy' style='max-width: 350px;' alt='가지에 작은 새가 있고, 말풍선에 어셈블리 명령어가 포함된 4패널 밈 만화를 묘사합니다. 두 번째 패널에서, 프레임 밖에서 다른 말풍선이 나타나 "안녕 나야 키보드!"라고 소리칩니다. 세 번째 패널에서, 소리의 출처가 프레임에 있는 큰 까마귀로 보이며, 이제 "중요한 메시지가 있어!"라고 소리칩니다. 마지막 패널에서, 작은 새를 클로즈업하여 무표정한 표정을 보입니다. 프레임 밖의 까마귀로부터 온 또 다른 말풍선은 단순히 문자 E를 담고 있습니다.' width='600' height='625' />

일부 시스템 콜이 커널 공간으로 점프하는 대신 vDSO라는 기술을 사용한다는 메모. 저는 이것에 대해 이야기할 시간이 없었지만, 꽤 흥미로우며 [읽어보는](https://en.wikipedia.org/wiki/VDSO) [것을](https://man7.org/linux/man-pages/man7/vdso.7.html) [권장](https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-3.html)합니다.

그리고 마지막으로, Unix 혐의에 대해 언급하자면: 많은 실행 관련 내용이 매우 Unix 특정적이어서 죄송합니다. macOS 또는 Linux 사용자라면 괜찮지만, Windows가 프로그램을 실행하거나 시스템 콜을 처리하는 방법에 훨씬 가까워지지는 않을 것입니다. 비록 CPU 아키텍처 내용은 모두 동일하지만요. 미래에 Windows 세계를 다루는 글을 쓰고 싶습니다.

## 감사의 말

이 글을 쓰는 동안 GPT-3.5 및 GPT-4와 꽤 많이 대화했습니다. 그들이 많이 거짓말을 했고 대부분의 정보가 쓸모가 없었지만, 때때로 문제를 해결하는 데 매우 도움이 되었습니다. 한계를 인식하고 그들이 말하는 모든 것에 대해 매우 회의적이라면 LLM 지원이 순 긍정적일 수 있습니다. 그렇지만, 그들은 글쓰기에 끔찍합니다. 그들이 당신을 위해 글을 쓰게 하지 마세요.

더 중요한 것은, 교정하고, 격려하고, 브레인스토밍을 도와준 모든 인간들에게 감사합니다 — 특히 Ani, B, Ben, Caleb, Kara, polypixeldev, Pradyun, Spencer, Nicky ([4장](/becoming-an-elf-lord)에서 멋진 엘프를 그려줌), 그리고 사랑하는 부모님께.

만약 당신이 십대이고 컴퓨터를 좋아하며 아직 [Hack Club Slack](https://hackclub.com/slack)에 있지 않다면, 지금 바로 가입해야 합니다. 생각과 진행 상황을 공유할 멋진 사람들의 커뮤니티가 없었다면 이 글을 쓰지 않았을 것입니다. 십대가 아니라면, 우리가 멋진 일을 계속할 수 있도록 [돈을 주셔야 합니다](https://hackclub.com/philanthropy/).

이 글의 모든 평범한 예술은 [Figma](https://figma.com/)에서 그렸습니다. 편집에는 [Obsidian](https://obsidian.md/)을 사용했고, 때때로 린팅에는 [Vale](https://vale.sh/)를 사용했습니다. 이 글의 Markdown 소스는 [GitHub에서 사용 가능](https://github.com/hackclub/putting-the-you-in-cpu/)하며 미래의 nitpick에 열려 있고, 모든 예술은 [Figma 커뮤니티 페이지](https://www.figma.com/community/file/1260699047973407903)에 게시되어 있습니다.

<img src='/images/cpu-pleading-face.png' loading='lazy' alt='사랑스러운 애원하는 얼굴을 가진 CPU.' width='280' height='280' style='max-width: 120px; margin: 0 auto;' />
